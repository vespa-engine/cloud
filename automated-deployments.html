---
# Copyright Verizon Media. All rights reserved.
title: Automated Deployments
---



<p>
Vespa Cloud automates deployment using <a href="/reference/deployment">deployment.xml</a> -
track and manage deployments in the console:
  <img alt="Vespa Cloud Console" src="img/console.png" />
</p>
<p>
<pre>
&lt;deployment version="1.0"&gt;
    &lt;prod&gt;
        &lt;region active="true"&gt;aws-us-east-1c&lt;/region&gt;
        &lt;delay minutes="10" /&gt;
        &lt;test&gt;aws-us-east-1c&lt;/test&gt;
        &lt;region active="true"&gt;aws-ap-northeast-1a&lt;/region&gt;
    &lt;/prod&gt;
&lt;/deployment&gt;
</pre>
This example deploys to two production zones - notes:
<ul>
  <li>A production test is configured after the first prod zone deployment, which a delay before test run</li>
  <li>System and Staging tests are implied and mandatory, no need to configure</li>
  <li>Potentially destructive change are guarded by
    <a href="https://docs.vespa.ai/documentation/reference/validation-overrides.html">validation-overrides</a> -
    this makes automated deployments safe and simple</li>
</ul>
</p>



<h2 id="steps">Steps</h2>
<p>
Follow steps in <a href="/getting-to-production">Getting to Production</a>,
or the full example in <a href="/album-recommendation-searcher">album-recommendation-searcher</a>.
Also see the <a href="/reference/vespa-cloud-api.html">API reference</a>. Summary:
<ol>
  <li><strong>Create deployment.xml</strong>
  <p>
    Configure where to deploy - <a href="/reference/zones">supported zones</a>.
  </p>
  </li><li><strong>Create system and staging tests</strong>
  <p>
    Create at least one <a href="/reference/testing#system-tests">system</a>
    and one <a href="/reference/testing#staging-tests">staging</a> test -
    production tests are optional.
  </p>
  </li><li><strong>Set up a deployment job</strong>
  <p>
    Configure a job in a tool like Github Actions -
    see <a href="#continuous-deployment">Continuous Deployment</a> below.
  </p>
  </li>
</ol>
Once set up, deploy changes to the production application
by checking in the change to the application source repository.
</p>



<h2 id="continuous-deployment">Continuous Deployment</h2>
<p>
Set up a job which builds the Vespa application and submits it to the Vespa cloud.
See the
<a href="https://github.com/vespa-engine/sample-apps/blob/master/.github/workflows/deploy-vespa-documentation-search.yaml">
sample GitHub workflow</a>.
</p><p>
The job should execute something like the following (modify as needed if not using git):
<pre>
$ mvn clean vespa:compileVersion \
  -DapiKey="${MY_API_KEY}"

$ mvn package vespa:submit \
  -Dvespa.compile.version="$(cat target/vespa.compile.version)"  \
  -DsourceUrl=$(git config --get remote.origin.url) \
  -DauthorEmail=$(git log -1 --format=%aE) \
  -DapiKey="${MY_API_KEY}"
</pre>
Track deployment at
<em>https://console.vespa.oath.cloud/tenant/mytenant/application/myapp/deployment</em> -
click "Deployment" in the console / refresh page.
</p><p>
<strong>Pro Tip:</strong> The <code>sourceUrl</code> is displayed in the console -
this can point to PR or diff or commit, whatever that is useful to trackthe change
</p>
<!-- ToDo: there should be a badge as well, add here when ready -->


<h3 id="keys">Keys</h3>
<p>
Deployment jobs use the
<a href="/reference/vespa-cloud-api#common-properties">Application API key</a>.
The API key can stored as a secret in the repository, see the sample above.
</p><p>
Some services like <a href="https://travis-ci.org">Travis CI</a> do not accept
multi-line values for Environment Variables in Settings.
A workaround is to use the output of
<pre>
$ openssl base64 -A -a &lt; mykey.pem &amp;&amp; echo
</pre>
in a variable, say VESPA_MYAPP_API_KEY, in Travis Settings.
VESPA_MYAPP_API_KEY is exported in the Travis environment, example output:
<pre>
Setting environment variables from repository settings
$ export VESPA_MYAPP_API_KEY=[secure]
</pre>
Then, before deploying/submitting to Vespa Cloud, regenerate the key value:
<pre>
MY_API_KEY=`echo $VESPA_MYAPP_API_KEY | openssl base64 -A -a -d`
</pre>
and use "${MY_API_KEY}" in the deploy/submit command.
</p>


<h3 id="vespa-compile-version">vespa:compileVersion</h3>
<p>
Vespa Cloud is <em>backwards compatible</em> on major versions.
Meaning, code compiled with an older version of Vespa APIs
can always be deployed to Vespa Cloud on same major version.
However, if the application package is compiled with a newer API version,
then deployed to an older version serving, deployment <span style="text-decoration: underline">can</span> fail.
</p><p>
This is normally not a problem as Vespa Cloud upgrades daily.
</p><p>
To make sure <em>forward compatibility</em> is not an issue,
<code>vespa:compileVersion</code> returns the <span style="text-decoration: underline">lowest</span>
version running in production for the application.
This version is then set in <code>vespa.compile.version</code> when building the application package.
</p>



<h2 id="deployment-and-testing">Deployment and Testing</h2>
<p>
Vespa applications are <em>compiled</em> against one version of the Vespa Java artifacts, 
and then deployed to nodes in the cloud where the <em>runtime</em> Vespa version is controlled by the system. 
This runtime, or <em>platform</em>, version is also continuously updated, independently of application updates. 
This leads to a number of possible combinations of application packages and platform versions for each application.
</p><p>
Instead of a simple <em>pipeline</em>, Vespa deployments are <em>orchestrated</em> such that any deployment of an application package
<code>X</code> to a production cluster with platform version <code>Y</code> is preceded by <em>system</em> and <em>staging</em>
tests using the same version pair; and likewise for any upgrade of the platform to version <code>Y</code> of a production
cluster running an application package <code>X</code>.
Good system and staging tests therefore guard against both unfortunate changes in the application, and in the Vespa platform.
</p><p>
<em><a href="/reference/testing#system-tests">System</a> and
<a href="/reference/testing#staging-tests">staging</a> tests are mandatory</em>.
</p><p>
When an application or platform change has been successfully verified in a system and staging tests,
it is deployed to a <a href="/reference/zones">production zone</a>.
This deployment job may also contain verification tests that need to succeed before the change rolls on to more zones.
Good production tests fail if a change is deployed in production which impacts the observed behavior of the application negatively,
typically by asserting on application metrics after a delay.
If the application is deployed in multiple prod zones,
this makes it possible to revert to the old version quickly by shifting traffic to another production zone.
</p><p>
Status of ongoing tests and deployments is found by clicking <em>Deployment</em> in the application view in the
<a href="http://console.vespa.ai">console</a>. <!--It is possible to delay the deployment to a region
by clicking the <em>pause</em> button, and to force through a deployment by clicking the <em>deploy</em> button. -->
Examples of advanced deployment configuration which can be set in <a href="/reference/deployment">deployment.xml</a> include:
<ul>
  <li>Deployment order and parallelism</li>
  <li>Time windows with no deployments</li>
  <li>Grace periods between deployments, and before their tests</li>
</ul>
</p>




<h2 id="production-deployments">Production deployments</h2>
<p>
Production jobs run sequentially by default, but can be configured to
<a href="/reference/deployment">run in parallel</a>.
Inside each zone, Vespa itself orchestrates the deployment,
such that the application may continue to serve,
even as subsets of its nodes are down for upgrade.
A production deployment job is not complete before the upgrade is completed on all nodes,
and all nodes report correct config generation.
</p><p>
When the Vespa platform is upgraded, each node has to restart with the new runtime;
this is typically slower than an application change by the user,
which often amounts only to a reconfiguration of smaller parts of the deployment.
</p>





<h2 id="deleting-an-application">Deleting an application</h2>
<p>
To delete an application, remove all production instances first.
</p><p>
<strong>WARNING!</strong> Following this guide will remove production instances and all data within them.
The data is unrecoverable.
<ol>
  <li>Remove all instances in <a href="/reference/deployment#instance">deployment.xml</a>:
<pre>
&lt;deployment version="1.0" /&gt;
</pre>
  </li>
  <li>Add/modify <a href="https://docs.vespa.ai/documentation/reference/validation-overrides.html">validation-overrides.xml</a>,
    allowing Vespa Cloud to remove production deployments:
<pre>
&lt;validation-overrides&gt;
    &lt;allow until="2020-09-30" comment="Removing aws-us-east-1c">deployment-removal&lt;/allow&gt;
&lt;/validation-overrides&gt;
</pre>
  </li>
  <li>Build the application package and submit.</li>
  <li>Delete the application in the <a href="http://console.vespa.ai">console</a>.</li>
  <li>Delete the CI job that builds and pushes new artifacts.</li>
</ol>
</p>



<h2 id="feature-switches-and-bucket-tests">Feature switches and bucket tests</h2>
<p>
With CD, it is not possible to hold off releasing a feature until it is done,
test it manually until convinced it works and then release it to production.
What to do instead?
The answer is <em>feature switches</em>: release new features to production as they are developed,
but include logic which keeps them deactivated until they are ready,
or until they have been verified in production with a subset of users.
</p><p>
<em>Bucket tests</em> is the practice of systematically testing new features or behavior for a controlled subset of users.
This is common practice when releasing new science models,
as they are difficult to verify in test, but can also be used for other features.
</p><p>
To test new behavior in Vespa, use a combination of
<a href="https://docs.vespa.ai/documentation/chained-components">search chains</a>
and
<a href="https://docs.vespa.ai/documentation/reference/schema-reference#rank-profile">rank profiles</a>,
controlled by
<a href="https://docs.vespa.ai/documentation/query-profiles">query profiles</a>,
where one query profiles correspond to one bucket.
These features support inheritance to make it easy to express variation without repetition.
</p><p>
Some times a new feature require
<a href="http://docs.vespa.ai/documentation/reference/schema-reference#modifying-schemas">
incompatible changes to a data field</a>.
To be able to CD such changes, it is necessary to create a new field containing the new version of the data.
This costs extra resources but less than the alternative: standing up a new system copy with the new data.
New fields can be added and populated while the system is live.
<p></p>
It should be mentioned that the need for incompatible changes can be decreased by making the semantics of the fields more precise.
E.g., if a field is defined as the "quality" of a document, where a higher number means higher quality,
a new algorithm which produces a different range and distribution will typically be an incompatible change.
However, if the field is defined more precisely as the average time spent on the document once it is clicked,
then a new algorithm which produces better estimates of this value will not be an incompatible change.
Using precise semantics also have the advantage of making it easier to understand
if the use of the data and its statistical properties are reasonable.
</p>



<h2 id="integration_testing">Integration testing</h2>
<p>
Another challenge with CD is integration testing across multiple services:
another service depends on this Vespa application for its own integration testing.
There are two ways to provide this: Either create an additional <em>application instance</em> for testing
or use test data in the production instance.
Using test data in production requires that some thought is given to separating this data from the real
data in queries.
A separate instance gives complete isolation,
but with some additional overhead,
and may not produce quite as realistic testing of queries,
as those will run only over the test data in the separate instance.
</p>



<h2 id="notes">Notes</h2>
<p>
Each application package build which is submitted to Vespa Cloud constitutes an application change which
must be tested and, if found healthy, deployed.
Similarly, each change to the Vespa platform, by the Vespa team, must be tested and deployed for all the hosted applications.
Vespa Cloud automates all these tests and deployments, with features including:
<ul>
  <li>chained runs of tests (see the <a href="/reference/testing.html">test reference</a>) and deployment,
    with retries of failed jobs;</li>
  <li>multiple concurrent instances of an application in each zone, upgraded as specified by the user,
    for testing application changes in a subset of the service before rolling them out further;</li>
  <li>separation of application and platform changes, making it easier to pinpoint breaking changes
    (application changes are always allowed when an upgrade fails, as they may be necessary to fix the breakage);</li>
  <li>cancellation of any current application roll-out, upon submission of a new application revision;</li>
  <li>throttling of platform upgrades, to detect unhealthy upgrades with a subset of applications; and</li>
  <li>cancellation of platform upgrades which are found unhealthy, across all applications.</li>
</ul>
With <em>Continuous Integration (CI)</em> <!-- link to something later -->
that builds and submits changes to the application as they are committed, Vespa Cloud thus provides
full-fledged Continuous Deployment (CD) of all its applications, both for application developers, and for the Vespa team.
</p>
