---
# Copyright Verizon Media. All rights reserved.
title: Index bootstrap
layout: page
---


<style>
  td {
    vertical-align: top;
  }
</style>

<p>
  When bootstrapping an index, there are a few decisions to make:
</p>
<ul class="list">
  <li>Node resource configuration</li>
  <li>Number of nodes needed</li>
</ul>
<p>
  The strategy is to iterate:
</p>
<ol class="list">
  <li>feed smaller chunks of data</li>
  <li>evaluate</li>
  <li>deploy new resource configurations</li>
  <li>wait for data migration to complete</li>
  <li>evaluate</li>
</ol>
<p>
  While doing this, ensure the cluster is never more than 50% full -
  this gives headroom to later increase/shrink the index
  and change schema configuration easily using automatic reindexing.
  Remember it is very easy to downscale resources after the bootstrap,
  and it saves a lot of time keeping the clusters within limits - hence max 50% during these steps.
</p>


<h2 id="preparations">Preparations</h2>
<p>
  The content node resource configuration should not have ranges for index bootstrap -
  this is a good starting point (make sure there are no ranges like [2,3]):
</p>
<pre>
&lt;nodes count="2"&gt;
    &lt;resources vcpu="2.0" memory="8Gb" disk="50Gb"/&gt;
&lt;/nodes&gt;
</pre>
<p>
  To evaluate how full the content cluster is, use <a href="monitoring">metrics</a> from content nodes - example:
</p>
<!-- ToDo: verify this is the correct metrics -->
<pre>
$ curl --cert data-plane-public-cert.pem --key data-plane-private-key.pem \
  https://vespacloud-docsearch.vespa-team.aws-us-east-1c.public.vespa.oath.cloud/metrics/v2/values | \
  jq '.nodes[] | select(.role|startswith("content/documentation")) |
  {   hostname:    .hostname,
      "disk.util": .node.metrics[] | select(.values."disk.util") | .values."disk.util",
      "mem.util":  .node.metrics[] | select(.values."mem.util")  | .values."mem.util"
  }'

...

{
  "hostname": "h2564a.prod.aws-us-east-1c.vespa-external.aws.oath.cloud",
  "disk.util": 0.646856704,
  "mem.util": 8.3981990814209
}
{
  "hostname": "h2550a.prod.aws-us-east-1c.vespa-external.aws.oath.cloud",
  "disk.util": 0.648052736,
  "mem.util": 8.228063583374
}
</pre>
<p>
  Metrics parsing notes:
</p>
<ul class="list">
  <li>Get the endpoint from the console, append <code>/metrics/v2/values</code> -
    this dumps metrics from all nodes</li>
  <li>Using <a href="https://stedolan.github.io/jq">jq</a> (or other JSON parsing tool),
    select nodes from a named content cluster (replace with current name), here called <em>documentation</em></li>
  <li>Print relevant metrics from the node</li>
</ul>
<p>
  Once able to dump the metrics above, you are ready to bootstrap the index.
</p>


<h2 id="bootstrap">Bootstrap</h2>
<table class="table">
  <thead>
  <th>Step</th><th>Description</th>
  </thead>
  <tbody>
  <tr>
    <td>1% feed</td>
    <td>
      <p>
        The purpose of this step is to feed a small step of the corpus to:
      </p>
        <ol class="list">
          <li>Estimate the memory and disk resource configuration</li>
          <li>Estimate the number of nodes required for the 10% phase</li>
        </ol>
      <p>
        Feed a small data set, observing the util metrics, stop no later than 50% memory/disk util.
        We recommend using the <a href="https://docs.vespa.ai/en/vespa-http-client.html">vespa-http-client</a>
        for feeding.
        <!-- ToDo: Cut'n paste example here -->
      </p>
      <p>
        The memory/disk sweet spot is a little tighter on memory than disk.
        The resource configuration should be modified so disk is in the 50-80% range of memory.
        Example: if memory util is 50%, disk util should be 30-45%.
        The reasoning is that memory is a more expensive component than disk,
        better over-allocate on disk and just track memory usage.
      </p>
      <p>
        Look at memory util. Say the 1% feed caused a 15% memory util -
        this means that the 10% feed will take 150%, or 3X more than the 50% max.
        There are two options, either increase memory/disk or add more nodes.
        A good rule of thumb at this stage is that the final 100% feed could fit on 4 or more nodes,
        and there is a 2-node minimum for redundancy.
        The default configuration at the start of this document is quite small,
        so a 3X at this stage means triple the disk and memory,
        and add more nodes in later steps.
      </p>
      <p>
        Deploy changes (if needed).
        Whenever node count increases or resource configuration is modified, new nodes are added,
        and data is migrated to new nodes. Example: growing from 2 to 3 nodes means each of the 2 current nodes
        will migrate 33% of their data to the new node.
        Read more in <a href="https://docs.vespa.ai/en/elastic-vespa.html">Elastic Vespa</a>.
        It saves time to let the cluster finish data migration before feeding more data.
        In this step it will be fast as the data volume is small,
        but nevertheless check the <code>vds.idealstate.merge_bucket.pending.average</code> metric.
        Wait for 0 for all nodes - this means data migration is completed:
      </p>
<pre>
$ curl --cert data-plane-public-cert.pem --key data-plane-private-key.pem \
  https://vespacloud-docsearch.vespa-team.aws-us-east-1c.public.vespa.oath.cloud/metrics/v2/values?consumer=Vespa | \
  jq '.nodes[] | select(.role|startswith("content/documentation")) |
    .services[] | select (.name=="vespa.distributor") |
      .metrics[].values."vds.idealstate.merge_bucket.pending.average"'

...

  0
  0
</pre>
      <p>
        At this point, you can validate that both memory and disk util is less than 5%,
        so the 10% feed will fit.
      </p>
    </td>
  </tr>
  <tr>
    <td>10% feed</td>
    <td>
      <p>
        Feed the 10% corpus, still observing util metrics.
      </p>
      <p>
        As the content cluster capacity is increased,
        it is normal to eventually be CPU bound in the container or content cluster,
        see the <a href="https://docs.vespa.ai/en/overview.html">Vespa Overview</a>.
        To find CPU utilization, add this to the JSON print in the "preparations" section:
<pre>
"cpu.util": .node.metrics[] | select(.values."cpu.util") | .values."cpu.util",
</pre>
        For container clusters, replace with <code>select(.role|startswith("container/default"))</code>
        (assuming the cluster is named <em>default</em>).
      </p>
      <p>
        A 10% feed is a great baseline for the full capacity requirements.
        Fine tune the resource config and number of hosts as needed.
        If you deploy changes, wait for the
        <code>vds.idealstate.merge_bucket.pending.average</code> metric to go to zero again.
        This now takes longer time as nodes are configured larger,
        it normally completes within a few hours.
      </p>
      <p>
        Again validate memory and disk util is less than 5% before the full feed.
      </p>
    </td>
  </tr>
  <tr>
    <td>100% feed</td>
    <td>
      <p>
        Feed the full data set, observing the metrics.
        You should be able to estimate timing by extrapolation, this is linear at this scale.
        At feed completion, observe the util metrics for the final fine tuning.
      </p>
      <p>
        A great exercise at this point is to add a node then reduce a node, and take the time to completion
        (<code>vds.idealstate.merge_bucket.pending.average</code> to 0).
        This is useful information when the application is in production,
        as you know the time to add or shrink capacity in advance.
      </p>
      <p>
        It can be a good idea to reduce node count to get the memory util closer to 70% at this step,
        to optimize for cost.
        However, do not spend too much time optimizing in this step, next step is normally
        <a href="https://docs.vespa.ai/en/performance/sizing-search.html">sizing for query load</a>.
        This will again possibly alter resource configuration and node counts / topology,
        but now you have a good grasp at how to easiest bootstrap the index for these experiments.
      </p>
    </td>
  </tr>
  </tbody>
</table>


<h2 id="further-reading">Further reading</h2>
<ul>
  <li><a href="https://docs.vespa.ai/en/reads-and-writes.html">Reads and Writes</a></li>
  <li><a href="https://docs.vespa.ai/en/performance/sizing-feeding.html">Vespa Feed Sizing Guide</a></li>
  <li><a href="https://cloud.vespa.ai/en/benchmarking">Vespa Cloud Benchmarking</a></li>
  <li><a href="https://cloud.vespa.ai/en/monitoring">Monitoring</a></li>
</ul>
